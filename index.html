<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WMSæ‹£è´§è·¯å¾„å¯¹æ¯”æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            overflow: hidden;
            user-select: none;
        }

        .game-container {
            display: flex;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        .left-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .right-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #81c784;
        }

        .canvas-container {
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 20px;
        }

        #gameCanvas {
            border: 2px solid #4caf50;
            border-radius: 8px;
            display: block;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, #66bb6a 0%, #43a047 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #81c784 0%, #66bb6a 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef5350 0%, #e53935 100%);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f1f8e9;
            border-radius: 6px;
            font-size: 14px;
        }

        .stat-label {
            color: #558b2f;
            font-weight: 500;
        }

        .stat-value {
            color: #33691e;
            font-weight: bold;
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .config-item label {
            font-size: 13px;
            color: #558b2f;
            font-weight: 500;
        }

        .config-item input {
            padding: 8px;
            border: 2px solid #a5d6a7;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .config-item input:focus {
            outline: none;
            border-color: #4caf50;
        }

        .item-list {
            max-height: 200px;
            overflow-y: auto;
            background: #f1f8e9;
            border-radius: 6px;
            padding: 10px;
        }

        .item-entry {
            display: flex;
            justify-content: space-between;
            padding: 6px 10px;
            background: white;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .item-entry:hover {
            background: #e8f5e9;
            transform: translateX(3px);
        }

        .item-entry.selected {
            background: #c8e6c9;
            border-left: 3px solid #4caf50;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 20px;
        }

        .result-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .result-card {
            padding: 15px;
            border-radius: 8px;
            background: #f1f8e9;
        }

        .result-card.ai {
            border-left: 4px solid #43a047;
        }

        .result-card.player {
            border-left: 4px solid #1976d2;
        }

        .result-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .efficiency-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            margin: 10px 0;
        }

        .efficiency-badge.excellent {
            background: #4caf50;
            color: white;
        }

        .efficiency-badge.good {
            background: #8bc34a;
            color: white;
        }

        .efficiency-badge.fair {
            background: #ffc107;
            color: #333;
        }

        .efficiency-badge.poor {
            background: #ff9800;
            color: white;
        }

        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .tutorial-content {
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 700px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        .tutorial-step {
            margin: 15px 0;
            padding-left: 30px;
            position: relative;
        }

        .tutorial-step::before {
            content: 'âœ“';
            position: absolute;
            left: 0;
            color: #4caf50;
            font-weight: bold;
            font-size: 18px;
        }

        .hidden {
            display: none !important;
        }

        .route-list {
            max-height: 150px;
            overflow-y: auto;
            background: #f1f8e9;
            border-radius: 6px;
            padding: 10px;
            font-size: 13px;
        }

        .route-item {
            padding: 5px;
            margin: 3px 0;
            background: white;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .route-item .remove-btn {
            background: #ef5350;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 8px;
            cursor: pointer;
            font-size: 11px;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #81c784;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #66bb6a;
        }
    </style>
</head>
<body>
    <!-- æ–°æ‰‹æ•™ç¨‹ -->
    <div id="tutorialOverlay" class="tutorial-overlay">
        <div class="tutorial-content">
            <h2 class="modal-title">ğŸ® æ¬¢è¿æ¥åˆ°WMSæ‹£è´§è·¯å¾„å¯¹æ¯”æ¸¸æˆ</h2>
            <div class="tutorial-step">é…ç½®æ¸¸æˆå‚æ•°ï¼ˆè´§ç‰©æ•°é‡ã€å°è½¦è½½é‡ç­‰ï¼‰</div>
            <div class="tutorial-step">ç‚¹å‡»"ç”Ÿæˆæ–°ä»»åŠ¡"åˆ›å»ºéšæœºè´§ç‰©</div>
            <div class="tutorial-step">åœ¨åœ°å›¾ä¸Šç‚¹å‡»è´§ç‰©è§„åˆ’ä½ çš„æ‹£è´§è·¯çº¿</div>
            <div class="tutorial-step">ç‚¹å‡»"å¼€å§‹å¯¹æ¯”"æŸ¥çœ‹ä½ çš„è·¯å¾„ä¸AIç®—æ³•çš„å¯¹æ¯”</div>
            <div class="tutorial-step">AIä½¿ç”¨A*ç®—æ³•+å®¹é‡çº¦æŸä¼˜åŒ–è·¯å¾„</div>
            <div class="tutorial-step">å°è¯•å‡»è´¥AIï¼Œæ‰¾åˆ°æœ€ä¼˜è·¯å¾„ï¼</div>
            <div style="margin-top: 30px; text-align: center;">
                <button class="btn" onclick="closeTutorial()">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
    </div>

    <!-- ä¸»æ¸¸æˆç•Œé¢ -->
    <div class="game-container">
        <!-- å·¦ä¾§é¢æ¿ï¼šAIç®—æ³•ä¿¡æ¯ -->
        <div class="left-panel panel">
            <div class="panel-title">ğŸ¤– AIç®—æ³•è·¯å¾„</div>
            
            <div class="control-group">
                <button class="btn btn-secondary" onclick="toggleAIPath()">æ˜¾ç¤º/éšè—AIè·¯å¾„</button>
                <button class="btn btn-secondary" onclick="showAIExplanation()">æŸ¥çœ‹AIå†³ç­–è¿‡ç¨‹</button>
            </div>

            <div class="panel-title" style="margin-top: 20px;">ğŸ“Š AIç»Ÿè®¡</div>
            <div class="stat-item">
                <span class="stat-label">æ‹£è´§è¿›åº¦</span>
                <span class="stat-value" id="aiProgress">0/0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">æ€»æ­¥æ•°</span>
                <span class="stat-value" id="aiSteps">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">æ€»æ—¶é—´</span>
                <span class="stat-value" id="aiTime">0s</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">å¸è´§æ¬¡æ•°</span>
                <span class="stat-value" id="aiUnloads">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">å½“å‰è½½é‡</span>
                <span class="stat-value" id="aiLoad">0</span>
            </div>

            <div class="panel-title" style="margin-top: 20px;">âš™ï¸ æ¸¸æˆé…ç½®</div>
            <div class="config-item">
                <label>ç½‘æ ¼å¤§å°</label>
                <input type="number" id="configGridSize" value="18" min="10" max="30">
            </div>
            <div class="config-item">
                <label>è´§ç‰©æ•°é‡èŒƒå›´</label>
                <div style="display: flex; gap: 5px;">
                    <input type="number" id="configItemMin" value="10" min="5" max="30" style="width: 50%;">
                    <input type="number" id="configItemMax" value="15" min="5" max="30" style="width: 50%;">
                </div>
            </div>
            <div class="config-item">
                <label>å°è½¦è½½é‡</label>
                <input type="number" id="configCapacity" value="200" min="20" max="500">
            </div>
            <div class="config-item">
                <label>ç§»åŠ¨é€Ÿåº¦(æ ¼/ç§’)</label>
                <input type="number" id="configSpeed" value="5" min="1" max="20">
            </div>
            <div class="config-item">
                <label>éšæœºç§å­</label>
                <input type="number" id="configSeed" value="12345">
            </div>
        </div>

        <!-- ä¸­é—´é¢æ¿ï¼šæ¸¸æˆåœ°å›¾ -->
        <div class="center-panel">
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn" onclick="generateNewLevel()">ğŸ² ç”Ÿæˆæ–°ä»»åŠ¡</button>
                <button class="btn" onclick="startComparison()" id="startBtn">â–¶ï¸ å¼€å§‹å¯¹æ¯”</button>
                <button class="btn btn-secondary" onclick="pauseGame()" id="pauseBtn">â¸ï¸ æš‚åœ</button>
                <button class="btn btn-danger" onclick="resetGame()">ğŸ”„ é‡ç½®</button>
                <button class="btn btn-secondary" onclick="loadExampleLevel()">ğŸ“‹ ç¤ºä¾‹å…³å¡</button>
            </div>

            <div class="canvas-container">
                <canvas id="gameCanvas" width="576" height="576"></canvas>
            </div>

            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <div class="stat-item" style="min-width: 120px;">
                    <span class="stat-label">å·²æ‹£ä»¶æ•°</span>
                    <span class="stat-value" id="collectedCount">0/0</span>
                </div>
                <div class="stat-item" style="min-width: 120px;">
                    <span class="stat-label">å‰©ä½™è´§ç‰©</span>
                    <span class="stat-value" id="remainingCount">0</span>
                </div>
            </div>
        </div>

        <!-- å³ä¾§é¢æ¿ï¼šç©å®¶è§„åˆ’ -->
        <div class="right-panel panel">
            <div class="panel-title">ğŸ‘¤ ç©å®¶è§„åˆ’è·¯å¾„</div>
            
            <div class="control-group">
                <button class="btn btn-secondary" onclick="clearPlayerRoute()">ğŸ—‘ï¸ æ¸…ç©ºè·¯çº¿</button>
                <button class="btn btn-secondary" onclick="undoLastItem()">â†¶ æ’¤é”€</button>
            </div>

            <div class="panel-title" style="margin-top: 20px;">
                ğŸ“ è§„åˆ’åˆ—è¡¨ 
                <span id="routeProgress" style="font-size: 13px; font-weight: normal; color: #666;">(0/0)</span>
            </div>
            <div id="playerRouteList" class="route-list">
                <div style="text-align: center; color: #999;">ç‚¹å‡»åœ°å›¾ä¸Šçš„è´§ç‰©æ·»åŠ åˆ°è·¯çº¿</div>
            </div>

            <div class="panel-title" style="margin-top: 20px;">ğŸ“Š ç©å®¶ç»Ÿè®¡</div>
            <div class="stat-item">
                <span class="stat-label">æ‹£è´§è¿›åº¦</span>
                <span class="stat-value" id="playerProgress">0/0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">æ€»æ­¥æ•°</span>
                <span class="stat-value" id="playerSteps">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">æ€»æ—¶é—´</span>
                <span class="stat-value" id="playerTime">0s</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">å¸è´§æ¬¡æ•°</span>
                <span class="stat-value" id="playerUnloads">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">å½“å‰è½½é‡</span>
                <span class="stat-value" id="playerLoad">0</span>
            </div>

            <div class="panel-title" style="margin-top: 20px;">ğŸ“¦ è´§ç‰©åˆ—è¡¨</div>
            <div id="itemList" class="item-list">
                <div style="text-align: center; color: #999;">æš‚æ— è´§ç‰©</div>
            </div>
        </div>
    </div>

    <!-- ç»“æœå¯¹æ¯”å¼¹çª— -->
    <div id="resultModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="modal-title">ğŸ‰ å¯¹æ¯”ç»“æœ</h2>
            <div id="resultContent"></div>
            <div style="margin-top: 30px; text-align: center; display: flex; gap: 10px; justify-content: center;">
                <button class="btn" onclick="closeResultModal()">å…³é—­</button>
                <button class="btn btn-secondary" onclick="generateNewLevel(); closeResultModal();">ä¸‹ä¸€å±€</button>
                <button class="btn btn-secondary" onclick="exportResult()">ğŸ“¥ å¯¼å‡ºç»“æœ</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== é…ç½® ====================
        let CONFIG = {
            gridSize: 18,
            cellPx: 32,
            itemCountMin: 10,
            itemCountMax: 15,
            itemWeightRange: [10, 90],
            vehicleCapacity: 200,
            moveSpeedCellsPerSecond: 5,
            seed: 12345,
            unloadTime: 1000 // å¸è´§æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        };

        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = {
            items: [],
            playerRoute: [],
            aiRoute: [],
            aiPath: [],
            playerPath: [],
            aiStats: { steps: 0, time: 0, unloads: 0, currentLoad: 0 },
            playerStats: { steps: 0, time: 0, unloads: 0, currentLoad: 0 },
            aiVehicle: { x: 0, y: 0, targetX: 0, targetY: 0, progress: 0 },
            playerVehicle: { x: 0, y: 0, targetX: 0, targetY: 0, progress: 0 },
            showAIPath: false,
            isRunning: false,
            isPaused: false,
            aiFinished: false,
            playerFinished: false,
            aiExplanation: []
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ==================== å·¥å…·å‡½æ•° ====================
        
        // ä¼ªéšæœºæ•°ç”Ÿæˆå™¨
        class Random {
            constructor(seed) {
                this.seed = seed;
            }
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }
        }

        // æ›¼å“ˆé¡¿è·ç¦»
        function manhattanDistance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        // A* å¯»è·¯ç®—æ³•
        function findPath(startX, startY, endX, endY) {
            const openSet = [];
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const startKey = `${startX},${startY}`;
            const endKey = `${endX},${endY}`;

            openSet.push({ x: startX, y: startY, key: startKey });
            gScore.set(startKey, 0);
            fScore.set(startKey, manhattanDistance(startX, startY, endX, endY));

            while (openSet.length > 0) {
                // æ‰¾åˆ° fScore æœ€å°çš„èŠ‚ç‚¹
                openSet.sort((a, b) => fScore.get(a.key) - fScore.get(b.key));
                const current = openSet.shift();

                if (current.x === endX && current.y === endY) {
                    // é‡å»ºè·¯å¾„
                    const path = [];
                    let curr = endKey;
                    while (cameFrom.has(curr)) {
                        const [x, y] = curr.split(',').map(Number);
                        path.unshift({ x, y });
                        curr = cameFrom.get(curr);
                    }
                    return path;
                }

                closedSet.add(current.key);

                // æ£€æŸ¥å››ä¸ªæ–¹å‘çš„é‚»å±…
                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];

                for (const neighbor of neighbors) {
                    if (neighbor.x < 0 || neighbor.x >= CONFIG.gridSize || 
                        neighbor.y < 0 || neighbor.y >= CONFIG.gridSize) {
                        continue;
                    }

                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    if (closedSet.has(neighborKey)) continue;

                    const tentativeGScore = gScore.get(current.key) + 1;

                    if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                        cameFrom.set(neighborKey, current.key);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + manhattanDistance(neighbor.x, neighbor.y, endX, endY));

                        if (!openSet.find(n => n.key === neighborKey)) {
                            openSet.push({ ...neighbor, key: neighborKey });
                        }
                    }
                }
            }

            return []; // æ— æ³•æ‰¾åˆ°è·¯å¾„
        }

        // ==================== AI ç®—æ³•ï¼šæ™ºèƒ½ä¼˜åŒ–çš„å®¹é‡çº¦æŸTSPæ±‚è§£ ====================
        
        // è¯„ä¼°ä¸€ä¸ªå®Œæ•´è·¯çº¿çš„è´¨é‡ï¼ˆæ€»è·ç¦»ï¼‰
        function evaluateRoute(itemSequence, capacity) {
            let totalDistance = 0;
            let currentX = 0, currentY = 0;
            let currentLoad = 0;
            
            for (const item of itemSequence) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å¸è´§
                if (currentLoad + item.weight > capacity) {
                    // è¿”å›åŸç‚¹å¸è´§
                    totalDistance += manhattanDistance(currentX, currentY, 0, 0);
                    currentX = 0;
                    currentY = 0;
                    currentLoad = 0;
                }
                
                // å‰å¾€è´§ç‰©ä½ç½®
                totalDistance += manhattanDistance(currentX, currentY, item.x, item.y);
                currentLoad += item.weight;
                currentX = item.x;
                currentY = item.y;
            }
            
            // è¿”å›åŸç‚¹
            totalDistance += manhattanDistance(currentX, currentY, 0, 0);
            
            return totalDistance;
        }
        
        // æ”¹è¿›çš„æ™ºèƒ½é€‰æ‹©ç®—æ³•
        function smartGreedyRoute(items, capacity) {
            const remaining = [...items];
            const route = [];
            let currentX = 0, currentY = 0;
            let currentLoad = 0;
            
            while (remaining.length > 0) {
                // æ‰¾åˆ°å¯ä»¥æ‹£å–çš„è´§ç‰©ï¼ˆä¸è¶…è½½ï¼‰
                const feasible = remaining.filter(item => item.weight <= capacity - currentLoad);
                
                if (feasible.length === 0) {
                    // éœ€è¦å¸è´§
                    currentX = 0;
                    currentY = 0;
                    currentLoad = 0;
                    continue;
                }
                
                // æ™ºèƒ½è¯„åˆ†ç³»ç»Ÿ
                let bestItem = null;
                let bestScore = Infinity;
                
                for (const item of feasible) {
                    const dist = manhattanDistance(currentX, currentY, item.x, item.y);
                    const returnDist = manhattanDistance(item.x, item.y, 0, 0);
                    
                    // è®¡ç®—è½½é‡åˆ©ç”¨ç‡ï¼ˆé¼“åŠ±è£…æ»¡ï¼‰
                    const loadUtilization = 1.0 - (currentLoad + item.weight) / capacity;
                    
                    // å‰ç»ï¼šçœ‹çœ‹æ‹£å–è¿™ä¸ªè´§ç‰©åï¼Œè¿˜èƒ½æ‹£å¤šå°‘å…¶ä»–è´§ç‰©
                    const afterLoad = currentLoad + item.weight;
                    const canPickNext = remaining.filter(other => 
                        other !== item && other.weight <= capacity - afterLoad
                    ).length;
                    
                    // ç»¼åˆè¯„åˆ†ï¼ˆè¶Šå°è¶Šå¥½ï¼‰
                    // - è·ç¦»å› ç´ ï¼šä¼˜å…ˆé€‰è¿‘çš„
                    // - è½½é‡å› ç´ ï¼šä¼˜å…ˆè£…æ»¡ï¼ˆå‡å°‘å¸è´§æ¬¡æ•°ï¼‰
                    // - å‰ç»å› ç´ ï¼šä¼˜å…ˆèƒ½ç»§ç»­æ‹£æ›´å¤šè´§ç‰©çš„é€‰æ‹©
                    // - è¿”ç¨‹å› ç´ ï¼šè€ƒè™‘å›ç¨‹è·ç¦»
                    const score = dist * 1.0 +                    // åˆ°è¾¾è·ç¦»
                                 loadUtilization * 20 +          // è½½é‡æƒ©ç½š
                                 (canPickNext === 0 ? 30 : 0) +  // æ­»è·¯æƒ©ç½š
                                 returnDist * 0.1;               // è¿”ç¨‹è·ç¦»è€ƒè™‘
                    
                    if (score < bestScore) {
                        bestScore = score;
                        bestItem = item;
                    }
                }
                
                if (bestItem) {
                    route.push(bestItem);
                    currentLoad += bestItem.weight;
                    currentX = bestItem.x;
                    currentY = bestItem.y;
                    remaining.splice(remaining.indexOf(bestItem), 1);
                }
            }
            
            return route;
        }
        
        // 2-optå±€éƒ¨ä¼˜åŒ–ç®—æ³•
        function twoOptImprove(itemSequence, capacity, maxIterations = 50) {
            let bestSequence = [...itemSequence];
            let bestDistance = evaluateRoute(bestSequence, capacity);
            let improved = true;
            let iterations = 0;
            
            while (improved && iterations < maxIterations) {
                improved = false;
                iterations++;
                
                for (let i = 0; i < bestSequence.length - 1; i++) {
                    for (let j = i + 2; j < bestSequence.length; j++) {
                        // å°è¯•åè½¬ i+1 åˆ° j ä¹‹é—´çš„é¡ºåº
                        const newSequence = [
                            ...bestSequence.slice(0, i + 1),
                            ...bestSequence.slice(i + 1, j + 1).reverse(),
                            ...bestSequence.slice(j + 1)
                        ];
                        
                        const newDistance = evaluateRoute(newSequence, capacity);
                        
                        if (newDistance < bestDistance) {
                            bestSequence = newSequence;
                            bestDistance = newDistance;
                            improved = true;
                        }
                    }
                }
            }
            
            return bestSequence;
        }
        
        // ä¸»AIç®—æ³•ï¼šç»“åˆå¤šç§ç­–ç•¥
        function calculateAIRoute(items, capacity) {
            const explanation = [];
            explanation.push({ step: 0, text: `å¼€å§‹AIæ™ºèƒ½è§„åˆ’ï¼Œå®¹é‡: ${capacity}` });
            
            // ç­–ç•¥1ï¼šæ™ºèƒ½è´ªå¿ƒç®—æ³•
            let bestSequence = smartGreedyRoute(items, capacity);
            let bestDistance = evaluateRoute(bestSequence, capacity);
            explanation.push({ step: 1, text: `è´ªå¿ƒç®—æ³•åˆå§‹è§£ï¼šé¢„è®¡æ€»è·ç¦» ${bestDistance}` });
            
            // ç­–ç•¥2ï¼š2-optä¼˜åŒ–
            const optimizedSequence = twoOptImprove(bestSequence, capacity);
            const optimizedDistance = evaluateRoute(optimizedSequence, capacity);
            
            if (optimizedDistance < bestDistance) {
                bestSequence = optimizedSequence;
                bestDistance = optimizedDistance;
                explanation.push({ step: 2, text: `2-optä¼˜åŒ–åï¼šæ€»è·ç¦»å‡å°‘åˆ° ${bestDistance}` });
            }
            
            // å¦‚æœè´§ç‰©è¾ƒå°‘ï¼Œå°è¯•æ›´å¤šèµ·å§‹ç­–ç•¥
            if (items.length <= 12) {
                // ç­–ç•¥3ï¼šæŒ‰è·ç¦»åŸç‚¹æ’åº
                const sortedByOrigin = [...items].sort((a, b) => 
                    manhattanDistance(0, 0, a.x, a.y) - manhattanDistance(0, 0, b.x, b.y)
                );
                const originDistance = evaluateRoute(sortedByOrigin, capacity);
                
                if (originDistance < bestDistance) {
                    bestSequence = sortedByOrigin;
                    bestDistance = originDistance;
                    explanation.push({ step: 3, text: `æŒ‰è·ç¦»æ’åºç­–ç•¥æ›´ä¼˜ï¼š${bestDistance}` });
                }
            }
            
            // å°†æœ€ä¼˜åºåˆ—è½¬æ¢ä¸ºè·¯çº¿
            const route = [];
            let currentX = 0, currentY = 0;
            let currentLoad = 0;
            let stepCount = 0;
            
            for (const item of bestSequence) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å¸è´§
                if (currentLoad + item.weight > capacity) {
                    stepCount++;
                    explanation.push({ 
                        step: stepCount, 
                        text: `è½½é‡${currentLoad}+${item.weight}>${capacity}ï¼Œè¿”å›å¸è´§` 
                    });
                    route.push({ type: 'unload', x: 0, y: 0 });
                    currentX = 0;
                    currentY = 0;
                    currentLoad = 0;
                }
                
                // æ‹£å–è´§ç‰©
                stepCount++;
                const dist = manhattanDistance(currentX, currentY, item.x, item.y);
                explanation.push({ 
                    step: stepCount, 
                    text: `æ‹£å– ${item.id} (${item.x},${item.y}) é‡${item.weight}kgï¼Œè·ç¦»${dist}` 
                });
                route.push({ type: 'pickup', item: item, x: item.x, y: item.y });
                currentLoad += item.weight;
                currentX = item.x;
                currentY = item.y;
            }
            
            // æœ€åè¿”å›åŸç‚¹
            if (currentX !== 0 || currentY !== 0) {
                stepCount++;
                explanation.push({ step: stepCount, text: `å®Œæˆæ‹£è´§ï¼Œè¿”å›åŸç‚¹` });
                route.push({ type: 'return', x: 0, y: 0 });
            }
            
            explanation.push({ step: stepCount + 1, text: `æœ€ä¼˜æ–¹æ¡ˆæ€»è·ç¦»: ${bestDistance}` });
            
            return { route, explanation };
        }

        // å°†ç©å®¶è§„åˆ’çš„è·¯çº¿è½¬æ¢ä¸ºå¸¦è‡ªåŠ¨å¸è´§çš„å®Œæ•´è·¯çº¿
        function convertPlayerRouteWithUnload(playerRoute, capacity) {
            const routeSteps = [];
            let currentLoad = 0;

            for (const item of playerRoute) {
                // æ£€æŸ¥æ˜¯å¦éœ€è¦å¸è´§
                if (currentLoad + item.weight > capacity) {
                    // éœ€è¦å…ˆå›å»å¸è´§
                    routeSteps.push({ type: 'unload', x: 0, y: 0 });
                    currentLoad = 0;
                }
                
                // æ‹£å–è´§ç‰©
                routeSteps.push({ type: 'pickup', item: item, x: item.x, y: item.y });
                currentLoad += item.weight;
            }

            // æœ€åè¿”å›åŸç‚¹
            routeSteps.push({ type: 'return', x: 0, y: 0 });
            
            return routeSteps;
        }

        // å°†è·¯çº¿è½¬æ¢ä¸ºå®Œæ•´è·¯å¾„ï¼ˆåŒ…å«A*å¯»è·¯çš„æ¯ä¸€æ­¥ï¼‰
        function routeToPath(route) {
            const path = [];
            let currentX = 0, currentY = 0;

            for (const step of route) {
                const subPath = findPath(currentX, currentY, step.x, step.y);
                path.push(...subPath);
                path.push({ x: step.x, y: step.y, action: step.type, item: step.item });
                currentX = step.x;
                currentY = step.y;
            }

            return path;
        }

        // è®¡ç®—è·¯å¾„ç»Ÿè®¡
        function calculatePathStats(path, capacity) {
            let steps = path.length;
            let time = steps / CONFIG.moveSpeedCellsPerSecond;
            let unloads = 0;
            let currentLoad = 0;

            for (const point of path) {
                if (point.action === 'unload') {
                    unloads++;
                    currentLoad = 0;
                    time += CONFIG.unloadTime / 1000;
                } else if (point.action === 'pickup' && point.item) {
                    currentLoad += point.item.weight;
                }
            }

            return { steps, time, unloads };
        }

        // ==================== å…³å¡ç”Ÿæˆ ====================
        function generateLevel(seed) {
            const rng = new Random(seed);
            const items = [];
            const itemCount = rng.nextInt(CONFIG.itemCountMin, CONFIG.itemCountMax);
            const occupiedPositions = new Set(['0,0']); // èµ·ç‚¹ä¸èƒ½æ”¾è´§ç‰©

            for (let i = 0; i < itemCount; i++) {
                let x, y;
                do {
                    x = rng.nextInt(0, CONFIG.gridSize - 1);
                    y = rng.nextInt(0, CONFIG.gridSize - 1);
                } while (occupiedPositions.has(`${x},${y}`));

                const weight = rng.nextInt(CONFIG.itemWeightRange[0], CONFIG.itemWeightRange[1]);
                
                // æ£€æŸ¥æ˜¯å¦è¶…è½½
                if (weight > CONFIG.vehicleCapacity) {
                    alert(`è´§ç‰© item${i + 1} é‡é‡${weight}è¶…è¿‡è½½é‡${CONFIG.vehicleCapacity}ï¼Œå·²ç§»é™¤`);
                    continue;
                }

                occupiedPositions.add(`${x},${y}`);
                items.push({
                    id: `item${i + 1}`,
                    x,
                    y,
                    weight,
                    collected: false
                });
            }

            return items;
        }

        // ==================== æ¸²æŸ“ ====================
        function render() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç½‘æ ¼
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= CONFIG.gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CONFIG.cellPx, 0);
                ctx.lineTo(i * CONFIG.cellPx, CONFIG.gridSize * CONFIG.cellPx);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * CONFIG.cellPx);
                ctx.lineTo(CONFIG.gridSize * CONFIG.cellPx, i * CONFIG.cellPx);
                ctx.stroke();
            }

            // ç»˜åˆ¶èµ·ç‚¹
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(2, 2, CONFIG.cellPx - 4, CONFIG.cellPx - 4);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('èµ·ç‚¹', CONFIG.cellPx / 2, CONFIG.cellPx / 2);

            // ç»˜åˆ¶AIè·¯å¾„
            if (gameState.showAIPath && gameState.aiPath.length > 0) {
                ctx.strokeStyle = '#2e7d32';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(CONFIG.cellPx / 2, CONFIG.cellPx / 2);
                for (const point of gameState.aiPath) {
                    ctx.lineTo(point.x * CONFIG.cellPx + CONFIG.cellPx / 2, 
                              point.y * CONFIG.cellPx + CONFIG.cellPx / 2);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // ç»˜åˆ¶ç©å®¶è§„åˆ’è·¯å¾„ï¼ˆä½¿ç”¨A*ç®—æ³•æ˜¾ç¤ºå®é™…è·¯å¾„ï¼‰
            if (gameState.playerRoute.length > 0 && !gameState.isRunning) {
                // ä¿å­˜å½“å‰çŠ¶æ€
                ctx.save();
                
                ctx.strokeStyle = '#81c784';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                
                let currentX = 0, currentY = 0;
                
                // ä»èµ·ç‚¹å¼€å§‹
                ctx.moveTo(0 * CONFIG.cellPx + CONFIG.cellPx / 2, 
                          0 * CONFIG.cellPx + CONFIG.cellPx / 2);
                
                // ä¸ºæ¯ä¸ªè´§ç‰©è®¡ç®—å¹¶ç»˜åˆ¶è·¯å¾„
                for (const item of gameState.playerRoute) {
                    const path = findPath(currentX, currentY, item.x, item.y);
                    
                    // ç»˜åˆ¶è·¯å¾„ä¸Šçš„æ¯ä¸ªç‚¹
                    for (const point of path) {
                        ctx.lineTo(point.x * CONFIG.cellPx + CONFIG.cellPx / 2, 
                                  point.y * CONFIG.cellPx + CONFIG.cellPx / 2);
                    }
                    
                    currentX = item.x;
                    currentY = item.y;
                }
                
                // åªåœ¨è§„åˆ’å®Œæ‰€æœ‰è´§ç‰©åæ‰ç»˜åˆ¶è¿”å›åŸç‚¹çš„è·¯å¾„
                if (gameState.playerRoute.length === gameState.items.length) {
                    const returnPath = findPath(currentX, currentY, 0, 0);
                    for (const point of returnPath) {
                        ctx.lineTo(point.x * CONFIG.cellPx + CONFIG.cellPx / 2, 
                                  point.y * CONFIG.cellPx + CONFIG.cellPx / 2);
                    }
                }
                
                ctx.stroke();
                
                // æ¢å¤çŠ¶æ€ï¼ˆè‡ªåŠ¨æ¸…é™¤setLineDashï¼‰
                ctx.restore();
            }

            // ç»˜åˆ¶è´§ç‰©ï¼ˆåŒè‰²æ˜¾ç¤ºæ‹£è´§è¿›åº¦ï¼‰
            for (const item of gameState.items) {
                const centerX = item.x * CONFIG.cellPx + CONFIG.cellPx / 2;
                const centerY = item.y * CONFIG.cellPx + CONFIG.cellPx / 2;
                const radius = CONFIG.cellPx * 0.35;

                // æ£€æµ‹è¯¥è´§ç‰©æ˜¯å¦è¢«AIæ‹£å–
                let aiPicked = false;
                let playerPicked = false;
                
                if (gameState.isRunning || gameState.aiFinished) {
                    // æ£€æŸ¥AIæ˜¯å¦æ‹£å–äº†è¿™ä¸ªè´§ç‰©
                    const aiPickedItems = gameState.aiPath.slice(0, gameState.aiVehicle.pathIndex)
                        .filter(p => p.action === 'pickup' && p.item)
                        .map(p => p.item);
                    aiPicked = aiPickedItems.includes(item);
                    
                    // æ£€æŸ¥ç©å®¶æ˜¯å¦æ‹£å–äº†è¿™ä¸ªè´§ç‰©
                    const playerPickedItems = gameState.playerPath.slice(0, gameState.playerVehicle.pathIndex)
                        .filter(p => p.action === 'pickup' && p.item)
                        .map(p => p.item);
                    playerPicked = playerPickedItems.includes(item);
                }

                // ç»˜åˆ¶è´§ç‰© - å·¦åŠåœ†ï¼ˆè“è‰²/ç™½è‰²ä»£è¡¨ç©å®¶ï¼‰
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI * 0.5, Math.PI * 1.5);
                ctx.closePath();
                ctx.fillStyle = playerPicked ? '#e0e0e0' : '#2196F3'; // ç©å®¶æ‹£äº†å˜ç™½è‰²ï¼Œå¦åˆ™è“è‰²
                ctx.fill();
                
                // ç»˜åˆ¶è´§ç‰© - å³åŠåœ†ï¼ˆç»¿è‰²/ç™½è‰²ä»£è¡¨AIï¼‰
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI * 1.5, Math.PI * 0.5);
                ctx.closePath();
                ctx.fillStyle = aiPicked ? '#e0e0e0' : '#4CAF50'; // AIæ‹£äº†å˜ç™½è‰²ï¼Œå¦åˆ™ç»¿è‰²
                ctx.fill();
                ctx.restore();
                
                // ç»˜åˆ¶è¾¹æ¡†
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                // è´§ç‰©é‡é‡
                ctx.fillStyle = '#333';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.weight, centerX, centerY);

                // è´§ç‰©ID
                ctx.font = '9px Arial';
                ctx.fillText(item.id, centerX, centerY + CONFIG.cellPx * 0.5);
            }

            // ç»˜åˆ¶AIå°è½¦
            if (gameState.isRunning || gameState.aiFinished) {
                const aiX = gameState.aiVehicle.x * CONFIG.cellPx + CONFIG.cellPx / 2;
                const aiY = gameState.aiVehicle.y * CONFIG.cellPx + CONFIG.cellPx / 2;
                
                ctx.fillStyle = '#1b5e20';
                ctx.beginPath();
                ctx.arc(aiX, aiY, CONFIG.cellPx * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('AI', aiX, aiY - 2);
                
                // æ˜¾ç¤ºè½½é‡
                ctx.font = '8px Arial';
                ctx.fillText(gameState.aiStats.currentLoad, aiX, aiY + 6);

                // AIå®Œæˆæç¤º
                if (gameState.aiFinished && !gameState.playerFinished) {
                    ctx.fillStyle = 'rgba(27, 94, 32, 0.8)';
                    ctx.fillRect(aiX - 40, aiY - 35, 80, 20);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.fillText('AIå·²å®Œæˆ', aiX, aiY - 25);
                }
            }

            // ç»˜åˆ¶ç©å®¶å°è½¦
            if (gameState.isRunning || gameState.playerFinished) {
                const playerX = gameState.playerVehicle.x * CONFIG.cellPx + CONFIG.cellPx / 2;
                const playerY = gameState.playerVehicle.y * CONFIG.cellPx + CONFIG.cellPx / 2;
                
                ctx.fillStyle = '#1565c0';
                ctx.beginPath();
                ctx.arc(playerX, playerY, CONFIG.cellPx * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 9px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ç©å®¶', playerX, playerY - 2);
                
                // æ˜¾ç¤ºè½½é‡
                ctx.font = '8px Arial';
                ctx.fillText(gameState.playerStats.currentLoad, playerX, playerY + 6);
            }
        }

        // ==================== æ¸¸æˆæ§åˆ¶ ====================
        function generateNewLevel() {
            // è¯»å–é…ç½®
            CONFIG.gridSize = parseInt(document.getElementById('configGridSize').value);
            CONFIG.itemCountMin = parseInt(document.getElementById('configItemMin').value);
            CONFIG.itemCountMax = parseInt(document.getElementById('configItemMax').value);
            CONFIG.vehicleCapacity = parseInt(document.getElementById('configCapacity').value);
            CONFIG.moveSpeedCellsPerSecond = parseInt(document.getElementById('configSpeed').value);
            CONFIG.seed = parseInt(document.getElementById('configSeed').value);

            // æ›´æ–°ç”»å¸ƒå¤§å°
            canvas.width = CONFIG.gridSize * CONFIG.cellPx;
            canvas.height = CONFIG.gridSize * CONFIG.cellPx;

            // ç”Ÿæˆå…³å¡
            gameState.items = generateLevel(CONFIG.seed);
            gameState.playerRoute = [];
            gameState.aiRoute = [];
            gameState.aiPath = [];
            gameState.playerPath = [];
            gameState.isRunning = false;
            gameState.isPaused = false;
            gameState.aiFinished = false;
            gameState.playerFinished = false;
            gameState.showAIPath = false;

            // é‡ç½®ç»Ÿè®¡
            gameState.aiStats = { steps: 0, time: 0, unloads: 0, currentLoad: 0 };
            gameState.playerStats = { steps: 0, time: 0, unloads: 0, currentLoad: 0 };
            gameState.aiVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.playerVehicle = { x: 0, y: 0, pathIndex: 0 };

            // è®¡ç®—AIè·¯å¾„
            const aiResult = calculateAIRoute([...gameState.items], CONFIG.vehicleCapacity);
            gameState.aiRoute = aiResult.route;
            gameState.aiExplanation = aiResult.explanation;
            gameState.aiPath = routeToPath(aiResult.route);
            
            const aiStats = calculatePathStats(gameState.aiPath, CONFIG.vehicleCapacity);
            gameState.aiStats = { ...aiStats, currentLoad: 0 };

            updateUI();
            render();
        }

        function startComparison() {
            if (gameState.playerRoute.length === 0) {
                alert('è¯·å…ˆè§„åˆ’ä½ çš„æ‹£è´§è·¯çº¿ï¼');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦è§„åˆ’äº†æ‰€æœ‰è´§ç‰©
            if (gameState.playerRoute.length !== gameState.items.length) {
                alert(`è¯·è§„åˆ’æ‰€æœ‰è´§ç‰©ï¼\nå½“å‰å·²è§„åˆ’: ${gameState.playerRoute.length}/${gameState.items.length}`);
                return;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„è´§ç‰©
            const uniqueItems = new Set(gameState.playerRoute);
            if (uniqueItems.size !== gameState.playerRoute.length) {
                alert('è·¯çº¿ä¸­æœ‰é‡å¤çš„è´§ç‰©ï¼Œè¯·æ£€æŸ¥ï¼');
                return;
            }

            // å°†ç©å®¶è·¯çº¿è½¬æ¢ä¸ºè·¯å¾„ï¼ˆå¸¦è‡ªåŠ¨å¸è´§æ£€æµ‹ï¼‰
            const playerRouteSteps = convertPlayerRouteWithUnload(gameState.playerRoute, CONFIG.vehicleCapacity);
            gameState.playerPath = routeToPath(playerRouteSteps);

            // é‡ç½®è½¦è¾†ä½ç½®
            gameState.aiVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.playerVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.aiStats.currentLoad = 0;
            gameState.playerStats.currentLoad = 0;
            gameState.aiStats.unloads = 0;
            gameState.playerStats.unloads = 0;
            gameState.isRunning = true;
            gameState.isPaused = false;
            gameState.aiFinished = false;
            gameState.playerFinished = false;

            // æ˜¾ç¤ºAIè·¯å¾„
            gameState.showAIPath = true;

            // å¼€å§‹åŠ¨ç”»
            animateVehicles();
        }

        function pauseGame() {
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pauseBtn').textContent = gameState.isPaused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ';
            if (!gameState.isPaused) {
                animateVehicles();
            }
        }

        function resetGame() {
            gameState.isRunning = false;
            gameState.isPaused = false;
            gameState.aiFinished = false;
            gameState.playerFinished = false;
            gameState.aiVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.playerVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.aiStats.currentLoad = 0;
            gameState.playerStats.currentLoad = 0;
            updateUI();
            render();
        }

        // ==================== åŠ¨ç”»ç³»ç»Ÿ ====================
        let lastFrameTime = 0;
        function animateVehicles() {
            if (!gameState.isRunning || gameState.isPaused) return;

            const now = Date.now();
            const deltaTime = lastFrameTime === 0 ? 0 : (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            const speed = CONFIG.moveSpeedCellsPerSecond;
            let aiMoved = false;
            let playerMoved = false;

            // ç§»åŠ¨AIå°è½¦
            if (!gameState.aiFinished && gameState.aiVehicle.pathIndex < gameState.aiPath.length) {
                const targetPoint = gameState.aiPath[gameState.aiVehicle.pathIndex];
                gameState.aiVehicle.x = targetPoint.x;
                gameState.aiVehicle.y = targetPoint.y;
                
                // å¤„ç†åŠ¨ä½œ
                if (targetPoint.action === 'pickup' && targetPoint.item) {
                    gameState.aiStats.currentLoad += targetPoint.item.weight;
                } else if (targetPoint.action === 'unload') {
                    gameState.aiStats.currentLoad = 0;
                    gameState.aiStats.unloads++;
                }
                
                gameState.aiVehicle.pathIndex++;
                gameState.aiStats.steps = gameState.aiVehicle.pathIndex;
                gameState.aiStats.time = gameState.aiStats.steps / speed;
                aiMoved = true;

                if (gameState.aiVehicle.pathIndex >= gameState.aiPath.length) {
                    gameState.aiFinished = true;
                }
            }

            // ç§»åŠ¨ç©å®¶å°è½¦
            if (!gameState.playerFinished && gameState.playerVehicle.pathIndex < gameState.playerPath.length) {
                const targetPoint = gameState.playerPath[gameState.playerVehicle.pathIndex];
                gameState.playerVehicle.x = targetPoint.x;
                gameState.playerVehicle.y = targetPoint.y;
                
                // å¤„ç†åŠ¨ä½œ
                if (targetPoint.action === 'pickup' && targetPoint.item) {
                    gameState.playerStats.currentLoad += targetPoint.item.weight;
                } else if (targetPoint.action === 'unload') {
                    gameState.playerStats.currentLoad = 0;
                    gameState.playerStats.unloads++;
                } else if (targetPoint.action === 'return') {
                    gameState.playerStats.currentLoad = 0;
                }
                
                gameState.playerVehicle.pathIndex++;
                gameState.playerStats.steps = gameState.playerVehicle.pathIndex;
                gameState.playerStats.time = gameState.playerStats.steps / speed;
                playerMoved = true;

                if (gameState.playerVehicle.pathIndex >= gameState.playerPath.length) {
                    gameState.playerFinished = true;
                }
            }

            updateUI();
            render();

            // æ£€æŸ¥æ˜¯å¦éƒ½å®Œæˆ
            if (gameState.aiFinished && gameState.playerFinished) {
                gameState.isRunning = false;
                setTimeout(showResult, 500);
            } else {
                setTimeout(() => requestAnimationFrame(animateVehicles), 1000 / speed);
            }
        }

        // ==================== UIæ›´æ–° ====================
        function updateUI() {
            const totalItems = gameState.items.length;
            
            // è®¡ç®—æ‹£è´§è¿›åº¦
            let aiPickedCount = 0;
            let playerPickedCount = 0;
            
            if (gameState.isRunning) {
                // è¿è¡Œä¸­ï¼šç»Ÿè®¡å·²æ‹£è´§ç‰©æ•°é‡
                aiPickedCount = gameState.aiPath.slice(0, gameState.aiVehicle.pathIndex)
                    .filter(p => p.action === 'pickup').length;
                playerPickedCount = gameState.playerPath.slice(0, gameState.playerVehicle.pathIndex)
                    .filter(p => p.action === 'pickup').length;
            } else if (gameState.aiFinished) {
                // å®Œæˆåï¼šå…¨éƒ¨æ‹£å®Œ
                aiPickedCount = totalItems;
                playerPickedCount = totalItems;
            }
            
            // AIç»Ÿè®¡
            document.getElementById('aiProgress').textContent = `${aiPickedCount}/${totalItems}`;
            document.getElementById('aiSteps').textContent = Math.round(gameState.aiStats.steps);
            document.getElementById('aiTime').textContent = gameState.aiStats.time.toFixed(1) + 's';
            document.getElementById('aiUnloads').textContent = gameState.aiStats.unloads;
            document.getElementById('aiLoad').textContent = gameState.aiStats.currentLoad;

            // ç©å®¶ç»Ÿè®¡
            document.getElementById('playerProgress').textContent = `${playerPickedCount}/${totalItems}`;
            document.getElementById('playerSteps').textContent = Math.round(gameState.playerStats.steps);
            document.getElementById('playerTime').textContent = gameState.playerStats.time.toFixed(1) + 's';
            document.getElementById('playerUnloads').textContent = gameState.playerStats.unloads;
            document.getElementById('playerLoad').textContent = gameState.playerStats.currentLoad;

            // å·²æ‹£ä»¶æ•°ï¼ˆè¿è¡Œä¸­æ˜¾ç¤ºè¿›åº¦ï¼‰
            const collectedCount = Math.max(aiPickedCount, playerPickedCount);
            document.getElementById('collectedCount').textContent = `${collectedCount}/${totalItems}`;
            document.getElementById('remainingCount').textContent = totalItems - collectedCount;

            // æ›´æ–°è´§ç‰©åˆ—è¡¨
            const itemListHTML = gameState.items.map(item => {
                const isSelected = gameState.playerRoute.includes(item);
                const selectedIndex = isSelected ? gameState.playerRoute.indexOf(item) + 1 : '';
                return `<div class="item-entry ${isSelected ? 'selected' : ''}" onclick="addToPlayerRoute('${item.id}')">
                    <span>${isSelected ? `âœ“ ` : ''}${item.id} (${item.x},${item.y})${isSelected ? ` - ç¬¬${selectedIndex}ä¸ª` : ''}</span>
                    <span style="font-weight: bold;">${item.weight}kg</span>
                </div>`;
            }).join('');
            document.getElementById('itemList').innerHTML = itemListHTML || '<div style="text-align: center; color: #999;">æš‚æ— è´§ç‰©</div>';

            // æ›´æ–°ç©å®¶è·¯çº¿åˆ—è¡¨
            const routeListHTML = gameState.playerRoute.map((item, index) => 
                `<div class="route-item">
                    <span>${index + 1}. ${item.id} (${item.weight}kg)</span>
                    <button class="remove-btn" onclick="removeFromRoute(${index})">åˆ é™¤</button>
                </div>`
            ).join('');
            document.getElementById('playerRouteList').innerHTML = routeListHTML || '<div style="text-align: center; color: #999;">ç‚¹å‡»åœ°å›¾ä¸Šçš„è´§ç‰©æ·»åŠ åˆ°è·¯çº¿</div>';
            
            // æ›´æ–°è§„åˆ’è¿›åº¦
            const progress = document.getElementById('routeProgress');
            const routeCount = gameState.playerRoute.length;
            const totalCount = gameState.items.length;
            progress.textContent = `(${routeCount}/${totalCount})`;
            
            // å¦‚æœå…¨éƒ¨è§„åˆ’å®Œæˆï¼Œé«˜äº®æ˜¾ç¤º
            if (routeCount === totalCount && totalCount > 0) {
                progress.style.color = '#4caf50';
                progress.style.fontWeight = 'bold';
                progress.textContent = `(${routeCount}/${totalCount}) âœ“`;
            } else if (routeCount > 0) {
                progress.style.color = '#ff9800';
                progress.style.fontWeight = 'normal';
            } else {
                progress.style.color = '#666';
                progress.style.fontWeight = 'normal';
            }
        }

        // ==================== ç©å®¶äº¤äº’ ====================
        canvas.addEventListener('click', (e) => {
            if (gameState.isRunning) return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CONFIG.cellPx);
            const y = Math.floor((e.clientY - rect.top) / CONFIG.cellPx);

            const item = gameState.items.find(i => i.x === x && i.y === y && !gameState.playerRoute.includes(i));
            if (item) {
                addToPlayerRoute(item.id);
            }
        });

        function addToPlayerRoute(itemId) {
            if (gameState.isRunning) return;
            
            const item = gameState.items.find(i => i.id === itemId);
            if (!item) return;
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»æ·»åŠ 
            if (gameState.playerRoute.includes(item)) {
                // å·²ç»æ·»åŠ è¿‡äº†ï¼Œå¯ä»¥é€‰æ‹©ä¸åšä»»ä½•æ“ä½œï¼Œæˆ–è€…æç¤ºç”¨æˆ·
                return;
            }
            
            gameState.playerRoute.push(item);
            updateUI();
            render();
            
            // å¦‚æœè§„åˆ’å®Œæˆï¼Œç»™å‡ºæç¤º
            if (gameState.playerRoute.length === gameState.items.length) {
                setTimeout(() => {
                    if (confirm('å·²è§„åˆ’å®Œæ‰€æœ‰è´§ç‰©ï¼æ˜¯å¦ç«‹å³å¼€å§‹å¯¹æ¯”ï¼Ÿ')) {
                        startComparison();
                    }
                }, 100);
            }
        }

        function removeFromRoute(index) {
            if (gameState.isRunning) return;
            gameState.playerRoute.splice(index, 1);
            updateUI();
            render();
        }

        function clearPlayerRoute() {
            if (gameState.isRunning) return;
            gameState.playerRoute = [];
            updateUI();
            render();
        }

        function undoLastItem() {
            if (gameState.isRunning) return;
            gameState.playerRoute.pop();
            updateUI();
            render();
        }

        function toggleAIPath() {
            gameState.showAIPath = !gameState.showAIPath;
            render();
        }

        function showAIExplanation() {
            if (gameState.aiExplanation.length === 0) {
                alert('è¯·å…ˆç”Ÿæˆä»»åŠ¡');
                return;
            }
            
            const explanation = gameState.aiExplanation.map(e => 
                `æ­¥éª¤ ${e.step}: ${e.text}`
            ).join('\n\n');
            
            alert('AIå†³ç­–è¿‡ç¨‹ï¼š\n\n' + explanation);
        }

        // ==================== ç»“æœå±•ç¤º ====================
        function showResult() {
            const efficiency = ((gameState.playerStats.steps - gameState.aiStats.steps) / gameState.aiStats.steps * 100);
            
            let grade, badgeClass, advice;
            if (efficiency <= 0) {
                grade = 'ğŸ† ç©å®¶æ›´ä¼˜ç§€ï¼';
                badgeClass = 'excellent';
                advice = 'å¤ªæ£’äº†ï¼ä½ çš„è·¯å¾„æ¯”AIæ›´ä¼˜ï¼';
            } else if (efficiency <= 10) {
                grade = 'ğŸ‘ è¡¨ç°è‰¯å¥½';
                badgeClass = 'good';
                advice = 'ä¸é”™ï¼å‡ ä¹å’ŒAIä¸€æ ·ä¼˜ç§€ï¼Œå†æ¥å†å‰ï¼';
            } else if (efficiency <= 30) {
                grade = 'ğŸ˜Š è¿˜å¯ä»¥';
                badgeClass = 'fair';
                advice = 'å¯ä»¥å°è¯•å‡å°‘ä¸å¿…è¦çš„å›é€€å’Œå¼¯è·¯';
            } else {
                grade = 'ğŸ’ª ç»§ç»­åŠªåŠ›';
                badgeClass = 'poor';
                advice = 'å»ºè®®ä¼˜å…ˆæ‹£å–è¾ƒè¿‘çš„è´§ç‰©ï¼Œå¹¶æ³¨æ„è½½é‡ç®¡ç†';
            }

            const resultHTML = `
                <div class="efficiency-badge ${badgeClass}">${grade}</div>
                <div class="result-comparison">
                    <div class="result-card ai">
                        <div class="result-title">ğŸ¤– AIç®—æ³•</div>
                        <div>æ€»æ­¥æ•°: <strong>${Math.round(gameState.aiStats.steps)}</strong></div>
                        <div>æ€»æ—¶é—´: <strong>${gameState.aiStats.time.toFixed(1)}ç§’</strong></div>
                        <div>å¸è´§æ¬¡æ•°: <strong>${gameState.aiStats.unloads}</strong></div>
                    </div>
                    <div class="result-card player">
                        <div class="result-title">ğŸ‘¤ ç©å®¶</div>
                        <div>æ€»æ­¥æ•°: <strong>${Math.round(gameState.playerStats.steps)}</strong></div>
                        <div>æ€»æ—¶é—´: <strong>${gameState.playerStats.time.toFixed(1)}ç§’</strong></div>
                        <div>å¸è´§æ¬¡æ•°: <strong>${gameState.playerStats.unloads}</strong></div>
                    </div>
                </div>
                <div style="padding: 15px; background: #f1f8e9; border-radius: 8px; margin-top: 10px;">
                    <div style="font-weight: bold; color: #558b2f;">æ•ˆç‡å·®å¼‚: ${efficiency > 0 ? '+' : ''}${efficiency.toFixed(1)}%</div>
                    <div style="margin-top: 10px; color: #666;">${advice}</div>
                </div>
            `;

            document.getElementById('resultContent').innerHTML = resultHTML;
            document.getElementById('resultModal').classList.remove('hidden');
        }

        function closeResultModal() {
            document.getElementById('resultModal').classList.add('hidden');
        }

        function exportResult() {
            const data = {
                config: CONFIG,
                aiStats: gameState.aiStats,
                playerStats: gameState.playerStats,
                efficiency: ((gameState.playerStats.steps - gameState.aiStats.steps) / gameState.aiStats.steps * 100).toFixed(1) + '%'
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `wms-result-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ==================== ç¤ºä¾‹å…³å¡ ====================
        function loadExampleLevel() {
            CONFIG.seed = 12345;
            document.getElementById('configSeed').value = 12345;
            generateNewLevel();
        }

        // ==================== æ–°æ‰‹æ•™ç¨‹ ====================
        function closeTutorial() {
            document.getElementById('tutorialOverlay').classList.add('hidden');
        }

        // ==================== åˆå§‹åŒ– ====================
        window.onload = () => {
            generateNewLevel();
        };
    </script>
</body>
</html>

