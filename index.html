<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WMS拣货路径对比游戏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            overflow: hidden;
            user-select: none;
        }

        .game-container {
            display: flex;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }

        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        .left-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .right-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #81c784;
        }

        .canvas-container {
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 20px;
        }

        #gameCanvas {
            border: 2px solid #4caf50;
            border-radius: 8px;
            display: block;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, #66bb6a 0%, #43a047 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #81c784 0%, #66bb6a 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef5350 0%, #e53935 100%);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f1f8e9;
            border-radius: 6px;
            font-size: 14px;
        }

        .stat-label {
            color: #558b2f;
            font-weight: 500;
        }

        .stat-value {
            color: #33691e;
            font-weight: bold;
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .config-item label {
            font-size: 13px;
            color: #558b2f;
            font-weight: 500;
        }

        .config-item input {
            padding: 8px;
            border: 2px solid #a5d6a7;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .config-item input:focus {
            outline: none;
            border-color: #4caf50;
        }

        .item-list {
            max-height: 200px;
            overflow-y: auto;
            background: #f1f8e9;
            border-radius: 6px;
            padding: 10px;
        }

        .item-entry {
            display: flex;
            justify-content: space-between;
            padding: 6px 10px;
            background: white;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .item-entry:hover {
            background: #e8f5e9;
            transform: translateX(3px);
        }

        .item-entry.selected {
            background: #c8e6c9;
            border-left: 3px solid #4caf50;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #2e7d32;
            margin-bottom: 20px;
        }

        .result-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .result-card {
            padding: 15px;
            border-radius: 8px;
            background: #f1f8e9;
        }

        .result-card.ai {
            border-left: 4px solid #43a047;
        }

        .result-card.player {
            border-left: 4px solid #1976d2;
        }

        .result-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .efficiency-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            margin: 10px 0;
        }

        .efficiency-badge.excellent {
            background: #4caf50;
            color: white;
        }

        .efficiency-badge.good {
            background: #8bc34a;
            color: white;
        }

        .efficiency-badge.fair {
            background: #ffc107;
            color: #333;
        }

        .efficiency-badge.poor {
            background: #ff9800;
            color: white;
        }

        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .tutorial-content {
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 700px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        .tutorial-step {
            margin: 15px 0;
            padding-left: 30px;
            position: relative;
        }

        .tutorial-step::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: #4caf50;
            font-weight: bold;
            font-size: 18px;
        }

        .hidden {
            display: none !important;
        }

        .route-list {
            max-height: 150px;
            overflow-y: auto;
            background: #f1f8e9;
            border-radius: 6px;
            padding: 10px;
            font-size: 13px;
        }

        .route-item {
            padding: 5px;
            margin: 3px 0;
            background: white;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .route-item .remove-btn {
            background: #ef5350;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 2px 8px;
            cursor: pointer;
            font-size: 11px;
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #81c784;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #66bb6a;
        }
    </style>
</head>
<body>
    <!-- 新手教程 -->
    <div id="tutorialOverlay" class="tutorial-overlay">
        <div class="tutorial-content">
            <h2 class="modal-title">🎮 欢迎来到WMS拣货路径对比游戏</h2>
            <div class="tutorial-step">配置游戏参数（货物数量、小车载重等）</div>
            <div class="tutorial-step">点击"生成新任务"创建随机货物</div>
            <div class="tutorial-step">在地图上点击货物规划你的拣货路线</div>
            <div class="tutorial-step">点击"开始对比"查看你的路径与AI算法的对比</div>
            <div class="tutorial-step">AI使用A*算法+容量约束优化路径</div>
            <div class="tutorial-step">尝试击败AI，找到最优路径！</div>
            <div style="margin-top: 30px; text-align: center;">
                <button class="btn" onclick="closeTutorial()">开始游戏</button>
            </div>
        </div>
    </div>

    <!-- 主游戏界面 -->
    <div class="game-container">
        <!-- 左侧面板：AI算法信息 -->
        <div class="left-panel panel">
            <div class="panel-title">🤖 AI算法路径</div>
            
            <div class="control-group">
                <button class="btn btn-secondary" onclick="toggleAIPath()">显示/隐藏AI路径</button>
                <button class="btn btn-secondary" onclick="showAIExplanation()">查看AI决策过程</button>
            </div>

            <div class="panel-title" style="margin-top: 20px;">📊 AI统计</div>
            <div class="stat-item">
                <span class="stat-label">拣货进度</span>
                <span class="stat-value" id="aiProgress">0/0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">总步数</span>
                <span class="stat-value" id="aiSteps">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">总时间</span>
                <span class="stat-value" id="aiTime">0s</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">卸货次数</span>
                <span class="stat-value" id="aiUnloads">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">当前载重</span>
                <span class="stat-value" id="aiLoad">0</span>
            </div>

            <div class="panel-title" style="margin-top: 20px;">⚙️ 游戏配置</div>
            <div class="config-item">
                <label>网格大小</label>
                <input type="number" id="configGridSize" value="18" min="10" max="30">
            </div>
            <div class="config-item">
                <label>货物数量范围</label>
                <div style="display: flex; gap: 5px;">
                    <input type="number" id="configItemMin" value="10" min="5" max="30" style="width: 50%;">
                    <input type="number" id="configItemMax" value="15" min="5" max="30" style="width: 50%;">
                </div>
            </div>
            <div class="config-item">
                <label>小车载重</label>
                <input type="number" id="configCapacity" value="200" min="20" max="500">
            </div>
            <div class="config-item">
                <label>移动速度(格/秒)</label>
                <input type="number" id="configSpeed" value="5" min="1" max="20">
            </div>
            <div class="config-item">
                <label>随机种子</label>
                <input type="number" id="configSeed" value="12345">
            </div>
        </div>

        <!-- 中间面板：游戏地图 -->
        <div class="center-panel">
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn" onclick="generateNewLevel()">🎲 生成新任务</button>
                <button class="btn" onclick="startComparison()" id="startBtn">▶️ 开始对比</button>
                <button class="btn btn-secondary" onclick="pauseGame()" id="pauseBtn">⏸️ 暂停</button>
                <button class="btn btn-danger" onclick="resetGame()">🔄 重置</button>
                <button class="btn btn-secondary" onclick="loadExampleLevel()">📋 示例关卡</button>
            </div>

            <div class="canvas-container">
                <canvas id="gameCanvas" width="576" height="576"></canvas>
            </div>

            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <div class="stat-item" style="min-width: 120px;">
                    <span class="stat-label">已拣件数</span>
                    <span class="stat-value" id="collectedCount">0/0</span>
                </div>
                <div class="stat-item" style="min-width: 120px;">
                    <span class="stat-label">剩余货物</span>
                    <span class="stat-value" id="remainingCount">0</span>
                </div>
            </div>
        </div>

        <!-- 右侧面板：玩家规划 -->
        <div class="right-panel panel">
            <div class="panel-title">👤 玩家规划路径</div>
            
            <div class="control-group">
                <button class="btn btn-secondary" onclick="clearPlayerRoute()">🗑️ 清空路线</button>
                <button class="btn btn-secondary" onclick="undoLastItem()">↶ 撤销</button>
            </div>

            <div class="panel-title" style="margin-top: 20px;">
                📝 规划列表 
                <span id="routeProgress" style="font-size: 13px; font-weight: normal; color: #666;">(0/0)</span>
            </div>
            <div id="playerRouteList" class="route-list">
                <div style="text-align: center; color: #999;">点击地图上的货物添加到路线</div>
            </div>

            <div class="panel-title" style="margin-top: 20px;">📊 玩家统计</div>
            <div class="stat-item">
                <span class="stat-label">拣货进度</span>
                <span class="stat-value" id="playerProgress">0/0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">总步数</span>
                <span class="stat-value" id="playerSteps">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">总时间</span>
                <span class="stat-value" id="playerTime">0s</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">卸货次数</span>
                <span class="stat-value" id="playerUnloads">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">当前载重</span>
                <span class="stat-value" id="playerLoad">0</span>
            </div>

            <div class="panel-title" style="margin-top: 20px;">📦 货物列表</div>
            <div id="itemList" class="item-list">
                <div style="text-align: center; color: #999;">暂无货物</div>
            </div>
        </div>
    </div>

    <!-- 结果对比弹窗 -->
    <div id="resultModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="modal-title">🎉 对比结果</h2>
            <div id="resultContent"></div>
            <div style="margin-top: 30px; text-align: center; display: flex; gap: 10px; justify-content: center;">
                <button class="btn" onclick="closeResultModal()">关闭</button>
                <button class="btn btn-secondary" onclick="generateNewLevel(); closeResultModal();">下一局</button>
                <button class="btn btn-secondary" onclick="exportResult()">📥 导出结果</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== 配置 ====================
        let CONFIG = {
            gridSize: 18,
            cellPx: 32,
            itemCountMin: 10,
            itemCountMax: 15,
            itemWeightRange: [10, 90],
            vehicleCapacity: 200,
            moveSpeedCellsPerSecond: 5,
            seed: 12345,
            unloadTime: 1000 // 卸货时间（毫秒）
        };

        // ==================== 游戏状态 ====================
        let gameState = {
            items: [],
            playerRoute: [],
            aiRoute: [],
            aiPath: [],
            playerPath: [],
            aiStats: { steps: 0, time: 0, unloads: 0, currentLoad: 0 },
            playerStats: { steps: 0, time: 0, unloads: 0, currentLoad: 0 },
            aiVehicle: { x: 0, y: 0, targetX: 0, targetY: 0, progress: 0 },
            playerVehicle: { x: 0, y: 0, targetX: 0, targetY: 0, progress: 0 },
            showAIPath: false,
            isRunning: false,
            isPaused: false,
            aiFinished: false,
            playerFinished: false,
            aiExplanation: []
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ==================== 工具函数 ====================
        
        // 伪随机数生成器
        class Random {
            constructor(seed) {
                this.seed = seed;
            }
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }
        }

        // 曼哈顿距离
        function manhattanDistance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        // A* 寻路算法
        function findPath(startX, startY, endX, endY) {
            const openSet = [];
            const closedSet = new Set();
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const startKey = `${startX},${startY}`;
            const endKey = `${endX},${endY}`;

            openSet.push({ x: startX, y: startY, key: startKey });
            gScore.set(startKey, 0);
            fScore.set(startKey, manhattanDistance(startX, startY, endX, endY));

            while (openSet.length > 0) {
                // 找到 fScore 最小的节点
                openSet.sort((a, b) => fScore.get(a.key) - fScore.get(b.key));
                const current = openSet.shift();

                if (current.x === endX && current.y === endY) {
                    // 重建路径
                    const path = [];
                    let curr = endKey;
                    while (cameFrom.has(curr)) {
                        const [x, y] = curr.split(',').map(Number);
                        path.unshift({ x, y });
                        curr = cameFrom.get(curr);
                    }
                    return path;
                }

                closedSet.add(current.key);

                // 检查四个方向的邻居
                const neighbors = [
                    { x: current.x + 1, y: current.y },
                    { x: current.x - 1, y: current.y },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x, y: current.y - 1 }
                ];

                for (const neighbor of neighbors) {
                    if (neighbor.x < 0 || neighbor.x >= CONFIG.gridSize || 
                        neighbor.y < 0 || neighbor.y >= CONFIG.gridSize) {
                        continue;
                    }

                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    if (closedSet.has(neighborKey)) continue;

                    const tentativeGScore = gScore.get(current.key) + 1;

                    if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                        cameFrom.set(neighborKey, current.key);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + manhattanDistance(neighbor.x, neighbor.y, endX, endY));

                        if (!openSet.find(n => n.key === neighborKey)) {
                            openSet.push({ ...neighbor, key: neighborKey });
                        }
                    }
                }
            }

            return []; // 无法找到路径
        }

        // ==================== AI 算法：智能优化的容量约束TSP求解 ====================
        
        // 评估一个完整路线的质量（总距离）
        function evaluateRoute(itemSequence, capacity) {
            let totalDistance = 0;
            let currentX = 0, currentY = 0;
            let currentLoad = 0;
            
            for (const item of itemSequence) {
                // 检查是否需要卸货
                if (currentLoad + item.weight > capacity) {
                    // 返回原点卸货
                    totalDistance += manhattanDistance(currentX, currentY, 0, 0);
                    currentX = 0;
                    currentY = 0;
                    currentLoad = 0;
                }
                
                // 前往货物位置
                totalDistance += manhattanDistance(currentX, currentY, item.x, item.y);
                currentLoad += item.weight;
                currentX = item.x;
                currentY = item.y;
            }
            
            // 返回原点
            totalDistance += manhattanDistance(currentX, currentY, 0, 0);
            
            return totalDistance;
        }
        
        // 改进的智能选择算法
        function smartGreedyRoute(items, capacity) {
            const remaining = [...items];
            const route = [];
            let currentX = 0, currentY = 0;
            let currentLoad = 0;
            
            while (remaining.length > 0) {
                // 找到可以拣取的货物（不超载）
                const feasible = remaining.filter(item => item.weight <= capacity - currentLoad);
                
                if (feasible.length === 0) {
                    // 需要卸货
                    currentX = 0;
                    currentY = 0;
                    currentLoad = 0;
                    continue;
                }
                
                // 智能评分系统
                let bestItem = null;
                let bestScore = Infinity;
                
                for (const item of feasible) {
                    const dist = manhattanDistance(currentX, currentY, item.x, item.y);
                    const returnDist = manhattanDistance(item.x, item.y, 0, 0);
                    
                    // 计算载重利用率（鼓励装满）
                    const loadUtilization = 1.0 - (currentLoad + item.weight) / capacity;
                    
                    // 前瞻：看看拣取这个货物后，还能拣多少其他货物
                    const afterLoad = currentLoad + item.weight;
                    const canPickNext = remaining.filter(other => 
                        other !== item && other.weight <= capacity - afterLoad
                    ).length;
                    
                    // 综合评分（越小越好）
                    // - 距离因素：优先选近的
                    // - 载重因素：优先装满（减少卸货次数）
                    // - 前瞻因素：优先能继续拣更多货物的选择
                    // - 返程因素：考虑回程距离
                    const score = dist * 1.0 +                    // 到达距离
                                 loadUtilization * 20 +          // 载重惩罚
                                 (canPickNext === 0 ? 30 : 0) +  // 死路惩罚
                                 returnDist * 0.1;               // 返程距离考虑
                    
                    if (score < bestScore) {
                        bestScore = score;
                        bestItem = item;
                    }
                }
                
                if (bestItem) {
                    route.push(bestItem);
                    currentLoad += bestItem.weight;
                    currentX = bestItem.x;
                    currentY = bestItem.y;
                    remaining.splice(remaining.indexOf(bestItem), 1);
                }
            }
            
            return route;
        }
        
        // 2-opt局部优化算法
        function twoOptImprove(itemSequence, capacity, maxIterations = 50) {
            let bestSequence = [...itemSequence];
            let bestDistance = evaluateRoute(bestSequence, capacity);
            let improved = true;
            let iterations = 0;
            
            while (improved && iterations < maxIterations) {
                improved = false;
                iterations++;
                
                for (let i = 0; i < bestSequence.length - 1; i++) {
                    for (let j = i + 2; j < bestSequence.length; j++) {
                        // 尝试反转 i+1 到 j 之间的顺序
                        const newSequence = [
                            ...bestSequence.slice(0, i + 1),
                            ...bestSequence.slice(i + 1, j + 1).reverse(),
                            ...bestSequence.slice(j + 1)
                        ];
                        
                        const newDistance = evaluateRoute(newSequence, capacity);
                        
                        if (newDistance < bestDistance) {
                            bestSequence = newSequence;
                            bestDistance = newDistance;
                            improved = true;
                        }
                    }
                }
            }
            
            return bestSequence;
        }
        
        // 主AI算法：结合多种策略
        function calculateAIRoute(items, capacity) {
            const explanation = [];
            explanation.push({ step: 0, text: `开始AI智能规划，容量: ${capacity}` });
            
            // 策略1：智能贪心算法
            let bestSequence = smartGreedyRoute(items, capacity);
            let bestDistance = evaluateRoute(bestSequence, capacity);
            explanation.push({ step: 1, text: `贪心算法初始解：预计总距离 ${bestDistance}` });
            
            // 策略2：2-opt优化
            const optimizedSequence = twoOptImprove(bestSequence, capacity);
            const optimizedDistance = evaluateRoute(optimizedSequence, capacity);
            
            if (optimizedDistance < bestDistance) {
                bestSequence = optimizedSequence;
                bestDistance = optimizedDistance;
                explanation.push({ step: 2, text: `2-opt优化后：总距离减少到 ${bestDistance}` });
            }
            
            // 如果货物较少，尝试更多起始策略
            if (items.length <= 12) {
                // 策略3：按距离原点排序
                const sortedByOrigin = [...items].sort((a, b) => 
                    manhattanDistance(0, 0, a.x, a.y) - manhattanDistance(0, 0, b.x, b.y)
                );
                const originDistance = evaluateRoute(sortedByOrigin, capacity);
                
                if (originDistance < bestDistance) {
                    bestSequence = sortedByOrigin;
                    bestDistance = originDistance;
                    explanation.push({ step: 3, text: `按距离排序策略更优：${bestDistance}` });
                }
            }
            
            // 将最优序列转换为路线
            const route = [];
            let currentX = 0, currentY = 0;
            let currentLoad = 0;
            let stepCount = 0;
            
            for (const item of bestSequence) {
                // 检查是否需要卸货
                if (currentLoad + item.weight > capacity) {
                    stepCount++;
                    explanation.push({ 
                        step: stepCount, 
                        text: `载重${currentLoad}+${item.weight}>${capacity}，返回卸货` 
                    });
                    route.push({ type: 'unload', x: 0, y: 0 });
                    currentX = 0;
                    currentY = 0;
                    currentLoad = 0;
                }
                
                // 拣取货物
                stepCount++;
                const dist = manhattanDistance(currentX, currentY, item.x, item.y);
                explanation.push({ 
                    step: stepCount, 
                    text: `拣取 ${item.id} (${item.x},${item.y}) 重${item.weight}kg，距离${dist}` 
                });
                route.push({ type: 'pickup', item: item, x: item.x, y: item.y });
                currentLoad += item.weight;
                currentX = item.x;
                currentY = item.y;
            }
            
            // 最后返回原点
            if (currentX !== 0 || currentY !== 0) {
                stepCount++;
                explanation.push({ step: stepCount, text: `完成拣货，返回原点` });
                route.push({ type: 'return', x: 0, y: 0 });
            }
            
            explanation.push({ step: stepCount + 1, text: `最优方案总距离: ${bestDistance}` });
            
            return { route, explanation };
        }

        // 将玩家规划的路线转换为带自动卸货的完整路线
        function convertPlayerRouteWithUnload(playerRoute, capacity) {
            const routeSteps = [];
            let currentLoad = 0;

            for (const item of playerRoute) {
                // 检查是否需要卸货
                if (currentLoad + item.weight > capacity) {
                    // 需要先回去卸货
                    routeSteps.push({ type: 'unload', x: 0, y: 0 });
                    currentLoad = 0;
                }
                
                // 拣取货物
                routeSteps.push({ type: 'pickup', item: item, x: item.x, y: item.y });
                currentLoad += item.weight;
            }

            // 最后返回原点
            routeSteps.push({ type: 'return', x: 0, y: 0 });
            
            return routeSteps;
        }

        // 将路线转换为完整路径（包含A*寻路的每一步）
        function routeToPath(route) {
            const path = [];
            let currentX = 0, currentY = 0;

            for (const step of route) {
                const subPath = findPath(currentX, currentY, step.x, step.y);
                path.push(...subPath);
                path.push({ x: step.x, y: step.y, action: step.type, item: step.item });
                currentX = step.x;
                currentY = step.y;
            }

            return path;
        }

        // 计算路径统计
        function calculatePathStats(path, capacity) {
            let steps = path.length;
            let time = steps / CONFIG.moveSpeedCellsPerSecond;
            let unloads = 0;
            let currentLoad = 0;

            for (const point of path) {
                if (point.action === 'unload') {
                    unloads++;
                    currentLoad = 0;
                    time += CONFIG.unloadTime / 1000;
                } else if (point.action === 'pickup' && point.item) {
                    currentLoad += point.item.weight;
                }
            }

            return { steps, time, unloads };
        }

        // ==================== 关卡生成 ====================
        function generateLevel(seed) {
            const rng = new Random(seed);
            const items = [];
            const itemCount = rng.nextInt(CONFIG.itemCountMin, CONFIG.itemCountMax);
            const occupiedPositions = new Set(['0,0']); // 起点不能放货物

            for (let i = 0; i < itemCount; i++) {
                let x, y;
                do {
                    x = rng.nextInt(0, CONFIG.gridSize - 1);
                    y = rng.nextInt(0, CONFIG.gridSize - 1);
                } while (occupiedPositions.has(`${x},${y}`));

                const weight = rng.nextInt(CONFIG.itemWeightRange[0], CONFIG.itemWeightRange[1]);
                
                // 检查是否超载
                if (weight > CONFIG.vehicleCapacity) {
                    alert(`货物 item${i + 1} 重量${weight}超过载重${CONFIG.vehicleCapacity}，已移除`);
                    continue;
                }

                occupiedPositions.add(`${x},${y}`);
                items.push({
                    id: `item${i + 1}`,
                    x,
                    y,
                    weight,
                    collected: false
                });
            }

            return items;
        }

        // ==================== 渲染 ====================
        function render() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制网格
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= CONFIG.gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CONFIG.cellPx, 0);
                ctx.lineTo(i * CONFIG.cellPx, CONFIG.gridSize * CONFIG.cellPx);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * CONFIG.cellPx);
                ctx.lineTo(CONFIG.gridSize * CONFIG.cellPx, i * CONFIG.cellPx);
                ctx.stroke();
            }

            // 绘制起点
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(2, 2, CONFIG.cellPx - 4, CONFIG.cellPx - 4);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('起点', CONFIG.cellPx / 2, CONFIG.cellPx / 2);

            // 绘制AI路径
            if (gameState.showAIPath && gameState.aiPath.length > 0) {
                ctx.strokeStyle = '#2e7d32';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(CONFIG.cellPx / 2, CONFIG.cellPx / 2);
                for (const point of gameState.aiPath) {
                    ctx.lineTo(point.x * CONFIG.cellPx + CONFIG.cellPx / 2, 
                              point.y * CONFIG.cellPx + CONFIG.cellPx / 2);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // 绘制玩家规划路径（使用A*算法显示实际路径）
            if (gameState.playerRoute.length > 0 && !gameState.isRunning) {
                // 保存当前状态
                ctx.save();
                
                ctx.strokeStyle = '#81c784';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                
                let currentX = 0, currentY = 0;
                
                // 从起点开始
                ctx.moveTo(0 * CONFIG.cellPx + CONFIG.cellPx / 2, 
                          0 * CONFIG.cellPx + CONFIG.cellPx / 2);
                
                // 为每个货物计算并绘制路径
                for (const item of gameState.playerRoute) {
                    const path = findPath(currentX, currentY, item.x, item.y);
                    
                    // 绘制路径上的每个点
                    for (const point of path) {
                        ctx.lineTo(point.x * CONFIG.cellPx + CONFIG.cellPx / 2, 
                                  point.y * CONFIG.cellPx + CONFIG.cellPx / 2);
                    }
                    
                    currentX = item.x;
                    currentY = item.y;
                }
                
                // 只在规划完所有货物后才绘制返回原点的路径
                if (gameState.playerRoute.length === gameState.items.length) {
                    const returnPath = findPath(currentX, currentY, 0, 0);
                    for (const point of returnPath) {
                        ctx.lineTo(point.x * CONFIG.cellPx + CONFIG.cellPx / 2, 
                                  point.y * CONFIG.cellPx + CONFIG.cellPx / 2);
                    }
                }
                
                ctx.stroke();
                
                // 恢复状态（自动清除setLineDash）
                ctx.restore();
            }

            // 绘制货物（双色显示拣货进度）
            for (const item of gameState.items) {
                const centerX = item.x * CONFIG.cellPx + CONFIG.cellPx / 2;
                const centerY = item.y * CONFIG.cellPx + CONFIG.cellPx / 2;
                const radius = CONFIG.cellPx * 0.35;

                // 检测该货物是否被AI拣取
                let aiPicked = false;
                let playerPicked = false;
                
                if (gameState.isRunning || gameState.aiFinished) {
                    // 检查AI是否拣取了这个货物
                    const aiPickedItems = gameState.aiPath.slice(0, gameState.aiVehicle.pathIndex)
                        .filter(p => p.action === 'pickup' && p.item)
                        .map(p => p.item);
                    aiPicked = aiPickedItems.includes(item);
                    
                    // 检查玩家是否拣取了这个货物
                    const playerPickedItems = gameState.playerPath.slice(0, gameState.playerVehicle.pathIndex)
                        .filter(p => p.action === 'pickup' && p.item)
                        .map(p => p.item);
                    playerPicked = playerPickedItems.includes(item);
                }

                // 绘制货物 - 左半圆（蓝色/白色代表玩家）
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI * 0.5, Math.PI * 1.5);
                ctx.closePath();
                ctx.fillStyle = playerPicked ? '#e0e0e0' : '#2196F3'; // 玩家拣了变白色，否则蓝色
                ctx.fill();
                
                // 绘制货物 - 右半圆（绿色/白色代表AI）
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, Math.PI * 1.5, Math.PI * 0.5);
                ctx.closePath();
                ctx.fillStyle = aiPicked ? '#e0e0e0' : '#4CAF50'; // AI拣了变白色，否则绿色
                ctx.fill();
                ctx.restore();
                
                // 绘制边框
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();

                // 货物重量
                ctx.fillStyle = '#333';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(item.weight, centerX, centerY);

                // 货物ID
                ctx.font = '9px Arial';
                ctx.fillText(item.id, centerX, centerY + CONFIG.cellPx * 0.5);
            }

            // 绘制AI小车
            if (gameState.isRunning || gameState.aiFinished) {
                const aiX = gameState.aiVehicle.x * CONFIG.cellPx + CONFIG.cellPx / 2;
                const aiY = gameState.aiVehicle.y * CONFIG.cellPx + CONFIG.cellPx / 2;
                
                ctx.fillStyle = '#1b5e20';
                ctx.beginPath();
                ctx.arc(aiX, aiY, CONFIG.cellPx * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('AI', aiX, aiY - 2);
                
                // 显示载重
                ctx.font = '8px Arial';
                ctx.fillText(gameState.aiStats.currentLoad, aiX, aiY + 6);

                // AI完成提示
                if (gameState.aiFinished && !gameState.playerFinished) {
                    ctx.fillStyle = 'rgba(27, 94, 32, 0.8)';
                    ctx.fillRect(aiX - 40, aiY - 35, 80, 20);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.fillText('AI已完成', aiX, aiY - 25);
                }
            }

            // 绘制玩家小车
            if (gameState.isRunning || gameState.playerFinished) {
                const playerX = gameState.playerVehicle.x * CONFIG.cellPx + CONFIG.cellPx / 2;
                const playerY = gameState.playerVehicle.y * CONFIG.cellPx + CONFIG.cellPx / 2;
                
                ctx.fillStyle = '#1565c0';
                ctx.beginPath();
                ctx.arc(playerX, playerY, CONFIG.cellPx * 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 9px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('玩家', playerX, playerY - 2);
                
                // 显示载重
                ctx.font = '8px Arial';
                ctx.fillText(gameState.playerStats.currentLoad, playerX, playerY + 6);
            }
        }

        // ==================== 游戏控制 ====================
        function generateNewLevel() {
            // 读取配置
            CONFIG.gridSize = parseInt(document.getElementById('configGridSize').value);
            CONFIG.itemCountMin = parseInt(document.getElementById('configItemMin').value);
            CONFIG.itemCountMax = parseInt(document.getElementById('configItemMax').value);
            CONFIG.vehicleCapacity = parseInt(document.getElementById('configCapacity').value);
            CONFIG.moveSpeedCellsPerSecond = parseInt(document.getElementById('configSpeed').value);
            CONFIG.seed = parseInt(document.getElementById('configSeed').value);

            // 更新画布大小
            canvas.width = CONFIG.gridSize * CONFIG.cellPx;
            canvas.height = CONFIG.gridSize * CONFIG.cellPx;

            // 生成关卡
            gameState.items = generateLevel(CONFIG.seed);
            gameState.playerRoute = [];
            gameState.aiRoute = [];
            gameState.aiPath = [];
            gameState.playerPath = [];
            gameState.isRunning = false;
            gameState.isPaused = false;
            gameState.aiFinished = false;
            gameState.playerFinished = false;
            gameState.showAIPath = false;

            // 重置统计
            gameState.aiStats = { steps: 0, time: 0, unloads: 0, currentLoad: 0 };
            gameState.playerStats = { steps: 0, time: 0, unloads: 0, currentLoad: 0 };
            gameState.aiVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.playerVehicle = { x: 0, y: 0, pathIndex: 0 };

            // 计算AI路径
            const aiResult = calculateAIRoute([...gameState.items], CONFIG.vehicleCapacity);
            gameState.aiRoute = aiResult.route;
            gameState.aiExplanation = aiResult.explanation;
            gameState.aiPath = routeToPath(aiResult.route);
            
            const aiStats = calculatePathStats(gameState.aiPath, CONFIG.vehicleCapacity);
            gameState.aiStats = { ...aiStats, currentLoad: 0 };

            updateUI();
            render();
        }

        function startComparison() {
            if (gameState.playerRoute.length === 0) {
                alert('请先规划你的拣货路线！');
                return;
            }

            // 检查是否规划了所有货物
            if (gameState.playerRoute.length !== gameState.items.length) {
                alert(`请规划所有货物！\n当前已规划: ${gameState.playerRoute.length}/${gameState.items.length}`);
                return;
            }

            // 检查是否有重复的货物
            const uniqueItems = new Set(gameState.playerRoute);
            if (uniqueItems.size !== gameState.playerRoute.length) {
                alert('路线中有重复的货物，请检查！');
                return;
            }

            // 将玩家路线转换为路径（带自动卸货检测）
            const playerRouteSteps = convertPlayerRouteWithUnload(gameState.playerRoute, CONFIG.vehicleCapacity);
            gameState.playerPath = routeToPath(playerRouteSteps);

            // 重置车辆位置
            gameState.aiVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.playerVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.aiStats.currentLoad = 0;
            gameState.playerStats.currentLoad = 0;
            gameState.aiStats.unloads = 0;
            gameState.playerStats.unloads = 0;
            gameState.isRunning = true;
            gameState.isPaused = false;
            gameState.aiFinished = false;
            gameState.playerFinished = false;

            // 显示AI路径
            gameState.showAIPath = true;

            // 开始动画
            animateVehicles();
        }

        function pauseGame() {
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pauseBtn').textContent = gameState.isPaused ? '▶️ 继续' : '⏸️ 暂停';
            if (!gameState.isPaused) {
                animateVehicles();
            }
        }

        function resetGame() {
            gameState.isRunning = false;
            gameState.isPaused = false;
            gameState.aiFinished = false;
            gameState.playerFinished = false;
            gameState.aiVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.playerVehicle = { x: 0, y: 0, pathIndex: 0 };
            gameState.aiStats.currentLoad = 0;
            gameState.playerStats.currentLoad = 0;
            updateUI();
            render();
        }

        // ==================== 动画系统 ====================
        let lastFrameTime = 0;
        function animateVehicles() {
            if (!gameState.isRunning || gameState.isPaused) return;

            const now = Date.now();
            const deltaTime = lastFrameTime === 0 ? 0 : (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            const speed = CONFIG.moveSpeedCellsPerSecond;
            let aiMoved = false;
            let playerMoved = false;

            // 移动AI小车
            if (!gameState.aiFinished && gameState.aiVehicle.pathIndex < gameState.aiPath.length) {
                const targetPoint = gameState.aiPath[gameState.aiVehicle.pathIndex];
                gameState.aiVehicle.x = targetPoint.x;
                gameState.aiVehicle.y = targetPoint.y;
                
                // 处理动作
                if (targetPoint.action === 'pickup' && targetPoint.item) {
                    gameState.aiStats.currentLoad += targetPoint.item.weight;
                } else if (targetPoint.action === 'unload') {
                    gameState.aiStats.currentLoad = 0;
                    gameState.aiStats.unloads++;
                }
                
                gameState.aiVehicle.pathIndex++;
                gameState.aiStats.steps = gameState.aiVehicle.pathIndex;
                gameState.aiStats.time = gameState.aiStats.steps / speed;
                aiMoved = true;

                if (gameState.aiVehicle.pathIndex >= gameState.aiPath.length) {
                    gameState.aiFinished = true;
                }
            }

            // 移动玩家小车
            if (!gameState.playerFinished && gameState.playerVehicle.pathIndex < gameState.playerPath.length) {
                const targetPoint = gameState.playerPath[gameState.playerVehicle.pathIndex];
                gameState.playerVehicle.x = targetPoint.x;
                gameState.playerVehicle.y = targetPoint.y;
                
                // 处理动作
                if (targetPoint.action === 'pickup' && targetPoint.item) {
                    gameState.playerStats.currentLoad += targetPoint.item.weight;
                } else if (targetPoint.action === 'unload') {
                    gameState.playerStats.currentLoad = 0;
                    gameState.playerStats.unloads++;
                } else if (targetPoint.action === 'return') {
                    gameState.playerStats.currentLoad = 0;
                }
                
                gameState.playerVehicle.pathIndex++;
                gameState.playerStats.steps = gameState.playerVehicle.pathIndex;
                gameState.playerStats.time = gameState.playerStats.steps / speed;
                playerMoved = true;

                if (gameState.playerVehicle.pathIndex >= gameState.playerPath.length) {
                    gameState.playerFinished = true;
                }
            }

            updateUI();
            render();

            // 检查是否都完成
            if (gameState.aiFinished && gameState.playerFinished) {
                gameState.isRunning = false;
                setTimeout(showResult, 500);
            } else {
                setTimeout(() => requestAnimationFrame(animateVehicles), 1000 / speed);
            }
        }

        // ==================== UI更新 ====================
        function updateUI() {
            const totalItems = gameState.items.length;
            
            // 计算拣货进度
            let aiPickedCount = 0;
            let playerPickedCount = 0;
            
            if (gameState.isRunning) {
                // 运行中：统计已拣货物数量
                aiPickedCount = gameState.aiPath.slice(0, gameState.aiVehicle.pathIndex)
                    .filter(p => p.action === 'pickup').length;
                playerPickedCount = gameState.playerPath.slice(0, gameState.playerVehicle.pathIndex)
                    .filter(p => p.action === 'pickup').length;
            } else if (gameState.aiFinished) {
                // 完成后：全部拣完
                aiPickedCount = totalItems;
                playerPickedCount = totalItems;
            }
            
            // AI统计
            document.getElementById('aiProgress').textContent = `${aiPickedCount}/${totalItems}`;
            document.getElementById('aiSteps').textContent = Math.round(gameState.aiStats.steps);
            document.getElementById('aiTime').textContent = gameState.aiStats.time.toFixed(1) + 's';
            document.getElementById('aiUnloads').textContent = gameState.aiStats.unloads;
            document.getElementById('aiLoad').textContent = gameState.aiStats.currentLoad;

            // 玩家统计
            document.getElementById('playerProgress').textContent = `${playerPickedCount}/${totalItems}`;
            document.getElementById('playerSteps').textContent = Math.round(gameState.playerStats.steps);
            document.getElementById('playerTime').textContent = gameState.playerStats.time.toFixed(1) + 's';
            document.getElementById('playerUnloads').textContent = gameState.playerStats.unloads;
            document.getElementById('playerLoad').textContent = gameState.playerStats.currentLoad;

            // 已拣件数（运行中显示进度）
            const collectedCount = Math.max(aiPickedCount, playerPickedCount);
            document.getElementById('collectedCount').textContent = `${collectedCount}/${totalItems}`;
            document.getElementById('remainingCount').textContent = totalItems - collectedCount;

            // 更新货物列表
            const itemListHTML = gameState.items.map(item => {
                const isSelected = gameState.playerRoute.includes(item);
                const selectedIndex = isSelected ? gameState.playerRoute.indexOf(item) + 1 : '';
                return `<div class="item-entry ${isSelected ? 'selected' : ''}" onclick="addToPlayerRoute('${item.id}')">
                    <span>${isSelected ? `✓ ` : ''}${item.id} (${item.x},${item.y})${isSelected ? ` - 第${selectedIndex}个` : ''}</span>
                    <span style="font-weight: bold;">${item.weight}kg</span>
                </div>`;
            }).join('');
            document.getElementById('itemList').innerHTML = itemListHTML || '<div style="text-align: center; color: #999;">暂无货物</div>';

            // 更新玩家路线列表
            const routeListHTML = gameState.playerRoute.map((item, index) => 
                `<div class="route-item">
                    <span>${index + 1}. ${item.id} (${item.weight}kg)</span>
                    <button class="remove-btn" onclick="removeFromRoute(${index})">删除</button>
                </div>`
            ).join('');
            document.getElementById('playerRouteList').innerHTML = routeListHTML || '<div style="text-align: center; color: #999;">点击地图上的货物添加到路线</div>';
            
            // 更新规划进度
            const progress = document.getElementById('routeProgress');
            const routeCount = gameState.playerRoute.length;
            const totalCount = gameState.items.length;
            progress.textContent = `(${routeCount}/${totalCount})`;
            
            // 如果全部规划完成，高亮显示
            if (routeCount === totalCount && totalCount > 0) {
                progress.style.color = '#4caf50';
                progress.style.fontWeight = 'bold';
                progress.textContent = `(${routeCount}/${totalCount}) ✓`;
            } else if (routeCount > 0) {
                progress.style.color = '#ff9800';
                progress.style.fontWeight = 'normal';
            } else {
                progress.style.color = '#666';
                progress.style.fontWeight = 'normal';
            }
        }

        // ==================== 玩家交互 ====================
        canvas.addEventListener('click', (e) => {
            if (gameState.isRunning) return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / CONFIG.cellPx);
            const y = Math.floor((e.clientY - rect.top) / CONFIG.cellPx);

            const item = gameState.items.find(i => i.x === x && i.y === y && !gameState.playerRoute.includes(i));
            if (item) {
                addToPlayerRoute(item.id);
            }
        });

        function addToPlayerRoute(itemId) {
            if (gameState.isRunning) return;
            
            const item = gameState.items.find(i => i.id === itemId);
            if (!item) return;
            
            // 检查是否已经添加
            if (gameState.playerRoute.includes(item)) {
                // 已经添加过了，可以选择不做任何操作，或者提示用户
                return;
            }
            
            gameState.playerRoute.push(item);
            updateUI();
            render();
            
            // 如果规划完成，给出提示
            if (gameState.playerRoute.length === gameState.items.length) {
                setTimeout(() => {
                    if (confirm('已规划完所有货物！是否立即开始对比？')) {
                        startComparison();
                    }
                }, 100);
            }
        }

        function removeFromRoute(index) {
            if (gameState.isRunning) return;
            gameState.playerRoute.splice(index, 1);
            updateUI();
            render();
        }

        function clearPlayerRoute() {
            if (gameState.isRunning) return;
            gameState.playerRoute = [];
            updateUI();
            render();
        }

        function undoLastItem() {
            if (gameState.isRunning) return;
            gameState.playerRoute.pop();
            updateUI();
            render();
        }

        function toggleAIPath() {
            gameState.showAIPath = !gameState.showAIPath;
            render();
        }

        function showAIExplanation() {
            if (gameState.aiExplanation.length === 0) {
                alert('请先生成任务');
                return;
            }
            
            const explanation = gameState.aiExplanation.map(e => 
                `步骤 ${e.step}: ${e.text}`
            ).join('\n\n');
            
            alert('AI决策过程：\n\n' + explanation);
        }

        // ==================== 结果展示 ====================
        function showResult() {
            const efficiency = ((gameState.playerStats.steps - gameState.aiStats.steps) / gameState.aiStats.steps * 100);
            
            let grade, badgeClass, advice;
            if (efficiency <= 0) {
                grade = '🏆 玩家更优秀！';
                badgeClass = 'excellent';
                advice = '太棒了！你的路径比AI更优！';
            } else if (efficiency <= 10) {
                grade = '👍 表现良好';
                badgeClass = 'good';
                advice = '不错！几乎和AI一样优秀，再接再厉！';
            } else if (efficiency <= 30) {
                grade = '😊 还可以';
                badgeClass = 'fair';
                advice = '可以尝试减少不必要的回退和弯路';
            } else {
                grade = '💪 继续努力';
                badgeClass = 'poor';
                advice = '建议优先拣取较近的货物，并注意载重管理';
            }

            const resultHTML = `
                <div class="efficiency-badge ${badgeClass}">${grade}</div>
                <div class="result-comparison">
                    <div class="result-card ai">
                        <div class="result-title">🤖 AI算法</div>
                        <div>总步数: <strong>${Math.round(gameState.aiStats.steps)}</strong></div>
                        <div>总时间: <strong>${gameState.aiStats.time.toFixed(1)}秒</strong></div>
                        <div>卸货次数: <strong>${gameState.aiStats.unloads}</strong></div>
                    </div>
                    <div class="result-card player">
                        <div class="result-title">👤 玩家</div>
                        <div>总步数: <strong>${Math.round(gameState.playerStats.steps)}</strong></div>
                        <div>总时间: <strong>${gameState.playerStats.time.toFixed(1)}秒</strong></div>
                        <div>卸货次数: <strong>${gameState.playerStats.unloads}</strong></div>
                    </div>
                </div>
                <div style="padding: 15px; background: #f1f8e9; border-radius: 8px; margin-top: 10px;">
                    <div style="font-weight: bold; color: #558b2f;">效率差异: ${efficiency > 0 ? '+' : ''}${efficiency.toFixed(1)}%</div>
                    <div style="margin-top: 10px; color: #666;">${advice}</div>
                </div>
            `;

            document.getElementById('resultContent').innerHTML = resultHTML;
            document.getElementById('resultModal').classList.remove('hidden');
        }

        function closeResultModal() {
            document.getElementById('resultModal').classList.add('hidden');
        }

        function exportResult() {
            const data = {
                config: CONFIG,
                aiStats: gameState.aiStats,
                playerStats: gameState.playerStats,
                efficiency: ((gameState.playerStats.steps - gameState.aiStats.steps) / gameState.aiStats.steps * 100).toFixed(1) + '%'
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `wms-result-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ==================== 示例关卡 ====================
        function loadExampleLevel() {
            CONFIG.seed = 12345;
            document.getElementById('configSeed').value = 12345;
            generateNewLevel();
        }

        // ==================== 新手教程 ====================
        function closeTutorial() {
            document.getElementById('tutorialOverlay').classList.add('hidden');
        }

        // ==================== 初始化 ====================
        window.onload = () => {
            generateNewLevel();
        };
    </script>
</body>
</html>

